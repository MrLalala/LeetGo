package main

func numTrees(n int) int {
	if n == 0 || n == 1 {
		return 1
	}
	dp := make([]int, n+1)
	// 对于 n 而言, 可以分别从 1,2,3...n作为根节点
	// 当1是根节点时, 左子树是0个, 右子树为 n-1个
	// 当2是根节点时, 左子树是1个, 右子树为 n-2个
	// ...
	// 当n-1是根节点时,左子树是n-2个,右子树为 1个
	// 当n是根节点时, 左子树是n-1个, 右子树为 0个
	// 所以 G(n) = G(0)*G(n-1) + G(1)*G(n-2) + ... + G(n-2)*G(1) + G(n-1)*G(0)
	dp[0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= i; j++ {
			dp[i] += dp[j-1] * dp[i-j]
		}
	}
	return dp[n]
}

func numTrees2(n int) int {
	if n <= 1 {
		return 1
	}
	dp := make([]int, n+1)
	dp[0] = 1
	// i: 序列的长度
	// j: 为根的节点(根不可能超过序列的长度)
	// 比如序列[1,2,3,4,5,6,7]
	// 假设当前 i=7, j=3
	// 左半部分就是[1,2], 右半部分就是[4,5,6,7]
	// 注意: 实际上, [4,5,6,7]组成的二叉搜索树本质上和[1,2,3,4]组成的二叉搜索树的数量是没有区别的!
	// 树的数量只和序列长度有关!
	// 同样的, [1,2,3,4]的组成又可以划分成若干个子问题, 都是由小及大计算得出的!
	// i是肯定大于j-1/ i-j的, 所以迭代由小及大计算即可
	for i := 1; i <= n; i++ {
		// 以树中的任意节点为跟节点
		// 左右两个区间所组成的树进行组合
		// 累加全部的结果
		for j := 1; j <= i; j++ {
			// 以任意位置的j为根节点
			// 左半部分长度是 [j-1], 右半部分长度是 [i-j]
			dp[i] += dp[j-1] * dp[i-j]
		}
	}
	return dp[n]
}
