package main

func minSteps(n int) int {
	// 快速查询

	// 质数就是就是本身(C+P*(n-1))
	// 合数需要分解质因数, 然后判断最小的合成次数

	// 想法如此, 做起来有点麻烦, 有更好的办法吗?

	var res int
	// 设想一下, 为啥可行呢?
	// 只需要保证质因数的和最小(由此可以保证复制的次数最小)
	// 比如99, 可分级的质因数为 3 * 3 * 9
	// 由1->3 需要 1P+2C(3)
	// 由3->9 需要 1P+2C(3)
	// 由9->99 需要 1P+10C(3)
	for i := 2; i <= n; i++ {
		for n%i == 0 {
			// 这里可以理解为, 一次C + i-1次P, 得到的总和就是 i 次
			res += i
			n /= i
		}
	}

	return res
}
