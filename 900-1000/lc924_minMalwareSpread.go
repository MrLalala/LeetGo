package main

func minMalwareSpread(graph [][]int, initial []int) int {
	groupNum := len(graph)

	// 如果某个点没有和任何感染点相连接, 则它没有任何影响
	// 如果某个点只和一个感染点相连接, 则删除可以带来较大的收益
	// 如果某个点和多个感染点相连接, 则删除它无作用.

	pointGroup := make([]int, groupNum) // 每个点的分组. 如果存在可达路径, 则其id相同
	groupSize := make(map[int]int)      // 每个组的联通分量
	groupId := 0
	for point := range pointGroup {
		if pointGroup[point] != 0 {
			continue
		}
		groupId++
		pointGroup[point] = groupId
		size := 1
		queue := []int{point}
		for len(queue) > 0 {
			current := queue[0]
			queue = queue[1:]
			for next := range graph[current] {
				if pointGroup[next] == 0 && graph[current][next] == 1 {
					size++
					queue = append(queue, next)
					pointGroup[next] = groupId
				}
			}
		}
		groupSize[groupId] = size
	}

	// 所有感染节点对应的分组的计数
	// 如果分组中只存在一个初始感染点, 此时消除它才是有意义的
	initialsGroup := make(map[int]int)
	for _, point := range initial {
		initialsGroup[pointGroup[point]]++
	}

	resultPoint := groupNum + 1
	var mvpRemove int
	for _, point := range initial {
		var remove int
		if initialsGroup[pointGroup[point]] == 1 {
			// 这个分组的联通分量, 就是去掉这个初始点带来的收益
			remove = groupSize[pointGroup[point]]
		}
		// 优先收益最大的, 其次编码最小的
		if remove > mvpRemove || (remove == mvpRemove && point < resultPoint) {
			resultPoint = point
			mvpRemove = remove
		}
	}
	return resultPoint
}
